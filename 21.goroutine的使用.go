// go的协程使用,相当于用户级线程,由用户开辟,协程使用的空间小
// 主协程退出会回收所有资源,也就是说只要协程(线程)执行结束,子协程就会自动结束,不管有没有运行都会结束

package main

import (
	"fmt"
	"sync"
)

// 子协程,类似于C++中线程函数的绑定
// 函数也就是相当于人类世界的动作(任务,行为)
func test() {
	for i := 0; i < 5; i++ {
		fmt.Println("子协程:", i)
	}
}

var wg sync.WaitGroup // 声明一个全局的同步原语

func test1() {
	defer wg.Done() // -----> 这个函数执行在defer中,所以最后执行
	for i := 0; i < 5; i++ {
		fmt.Println("子协程:", i)
	}
}

// 主协程
// 主协程一旦结束,子协程就会结束-----------》主协程,唯一的王者！！！！
func main() {
	// 协程的声明
	go test()

	// 主协程在1秒后结束
	// time.Sleep(time.Second * 1)

	// 结合defer使用
	// 执行子协程之前,先执行一个同步原语
	fmt.Println("---------子协程执行完毕-----------")
	wg.Add(1)
	go test1()
	// 主线程会等待子线程执行完毕,然后执行主线程
	wg.Wait()

	// 如果主函数什么都不声明,也就是延迟执行,那么子协程没有执行就会结束,因为主线程结束了
	fmt.Println("---------主协程执行完毕-----------")
}
